#!/usr/bin/env python3
"""
Web Pentester Agent
Security testing agent for web applications
Performs reconnaissance, vulnerability scanning, and exploitation

Based on CAI web_pentester agent design
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class WebPentesterAgent:
    """
    Web Application Security Testing Agent
    
    Capabilities:
    - Web reconnaissance (subdomain enum, port scanning, tech detection)
    - Vulnerability scanning (SQLi, XSS, CSRF, misconfigs)
    - Authentication testing (default creds, weak passwords)
    - Authorization bypass attempts
    - API endpoint discovery and testing
    """
    
    id: str = "web_pentester"
    name: str = "Web Pentester"
    model_name: str = "qwen3:1.7b"
    provider: str = "ollama"
    
    capabilities: List[str] = None
    tools: List[str] = None
    handoffs: List[str] = None
    
    description: str = "Security testing agent for web applications"
    
    def __post_init__(self):
        if self.capabilities is None:
            self.capabilities = [
                "web_reconnaissance",
                "vulnerability_scanning",
                "security_testing",
                "exploit_validation",
                "authentication_testing",
                "authorization_testing",
                "api_testing"
            ]
        
        if self.tools is None:
            self.tools = [
                "bash_exec",
                "filesystem_read",
                "filesystem_write",
                "web_fetch",
                "nmap_scan",
                "hash_file",
                "ssl_check"
            ]
        
        if self.handoffs is None:
            self.handoffs = [
                "retester",
                "report_agent"
            ]
    
    def get_system_prompt(self) -> str:
        """Get the system prompt for this agent"""
        return """You are a professional web application security tester.

Your role is to perform comprehensive security assessments of web applications to identify vulnerabilities before malicious actors can exploit them.

METHODOLOGY:
1. Reconnaissance Phase:
   - Identify target web application and technologies
   - Map out endpoints, forms, and functionality
   - Discover subdomains and hidden directories
   - Identify authentication and authorization mechanisms

2. Vulnerability Assessment:
   - Test for OWASP Top 10 vulnerabilities:
     * Injection flaws (SQL, command, LDAP, etc.)
     * Broken authentication and session management
     * Cross-Site Scripting (XSS)
     * Insecure Direct Object References (IDOR)
     * Security misconfiguration
     * Sensitive data exposure
     * Missing access controls
     * Cross-Site Request Forgery (CSRF)
     * Using components with known vulnerabilities
     * Insufficient logging and monitoring

3. Exploitation (with authorization):
   - Validate vulnerabilities are exploitable
   - Demonstrate impact with proof-of-concept
   - Document steps to reproduce
   - Assess severity and risk

4. Reporting:
   - Document all findings with evidence
   - Provide remediation recommendations
   - Classify by severity (Critical, High, Medium, Low)

IMPORTANT RULES:
- ONLY test targets explicitly authorized in the scope
- Do NOT perform destructive actions without approval
- Do NOT exfiltrate sensitive data
- Stop immediately if you encounter production systems outside scope
- All testing must be ethical and legal
- Document every action for the audit trail

TOOLS AVAILABLE:
- bash_exec: Execute commands (use cautiously)
- web_fetch: Retrieve web content
- nmap_scan: Network and port scanning
- filesystem operations: Read/write test results
- ssl_check: Validate SSL/TLS configuration

OUTPUT FORMAT:
For each finding, provide:
1. Vulnerability title and type
2. Affected endpoint/component
3. Severity rating (Critical/High/Medium/Low)
4. Proof of concept (steps to reproduce)
5. Impact assessment
6. Remediation recommendation

When you complete testing, you can handoff to:
- retester: For validation of findings
- report_agent: For professional report generation

Be thorough, methodical, and always prioritize responsible disclosure."""

    def get_instructions(self, context: Dict[str, Any]) -> str:
        """Get dynamic instructions based on context"""
        target = context.get("target", "")
        scope = context.get("scope", [])
        test_type = context.get("test_type", "comprehensive")
        
        instructions = f"""SECURITY ASSESSMENT TASK

Target: {target}
Authorized Scope: {', '.join(scope) if scope else 'See configuration'}
Assessment Type: {test_type}

"""
        
        if test_type == "quick":
            instructions += """QUICK ASSESSMENT:
- Focus on high-impact vulnerabilities
- Automated scanning only
- Time limit: 15 minutes
- Report top 5 findings
"""
        elif test_type == "comprehensive":
            instructions += """COMPREHENSIVE ASSESSMENT:
- Full OWASP Top 10 testing
- Manual verification of findings
- API endpoint testing
- Authentication/authorization testing
- Configuration review
- Provide detailed report
"""
        elif test_type == "targeted":
            focus_area = context.get("focus_area", "authentication")
            instructions += f"""TARGETED ASSESSMENT:
- Focus area: {focus_area}
- Deep dive into specific vulnerability class
- Manual testing and exploitation
- Detailed proof-of-concept
"""
        
        instructions += """
DELIVERABLES:
1. List of identified vulnerabilities
2. Proof-of-concept for each finding
3. Risk assessment and remediation guidance
4. Summary of testing performed

Begin your assessment now."""
        
        return instructions
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert agent to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "model_name": self.model_name,
            "provider": self.provider,
            "capabilities": self.capabilities,
            "tools": self.tools,
            "handoffs": self.handoffs,
            "description": self.description,
            "system_prompt": self.get_system_prompt()
        }


# Create default instance
web_pentester_agent = WebPentesterAgent()


if __name__ == "__main__":
    agent = WebPentesterAgent()
    
    print("="*60)
    print("WEB PENTESTER AGENT")
    print("="*60)
    print(f"ID: {agent.id}")
    print(f"Name: {agent.name}")
    print(f"Model: {agent.model_name}")
    print(f"Provider: {agent.provider}")
    print(f"Capabilities: {', '.join(agent.capabilities)}")
    print(f"Tools: {', '.join(agent.tools)}")
    print(f"Handoffs: {', '.join(agent.handoffs)}")
    print(f"\nSystem Prompt Length: {len(agent.get_system_prompt())} chars")
    
    # Test instructions
    context = {
        "target": "https://example.com",
        "scope": ["example.com", "api.example.com"],
        "test_type": "comprehensive"
    }
    instructions = agent.get_instructions(context)
    print(f"Instructions Length: {len(instructions)} chars")
    print("\n" + "="*60)
